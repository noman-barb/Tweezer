# SLM Module - Spatial Light Modulator Control

GPU-accelerated hologram generation and hardware control system for creating dynamic optical trap patterns in real-time. The system operates across two PCs connected via 10 Gigabit Ethernet with CUDA-optimized Gerchberg-Saxton algorithm.

## ğŸ“– Table of Contents

- [Architecture Overview](#architecture-overview)
- [Hardware Topology](#hardware-topology)
- [Hologram Generation](#hologram-generation)
- [Hardware Driver](#hardware-driver)
- [Algorithm Implementation](#algorithm-implementation)
- [Performance Optimization](#performance-optimization)
- [Network Communication](#network-communication)
- [API Reference](#api-reference)

## ğŸ—ï¸ Architecture Overview

The SLM module implements a **distributed two-PC architecture**:

- **Main Control PC**: generator_service.py performs GPU-accelerated hologram generation (CUDA)
- **SLM PC**: slm_service.py drives SLM hardware connected via PCIE
- **Communication**: 10 Gigabit Ethernet for hologram streaming

## ğŸ–§ Hardware Topology

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      SLM MODULE HARDWARE TOPOLOGY                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚                      MAIN CONTROL PC                                       â”‚
â”‚  â”‚                                                                             â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  â”‚              Dashboard / Control Interface                     â”‚        â”‚
â”‚  â”‚  â”‚                                                                 â”‚        â”‚
â”‚  â”‚  â”‚  - User specifies tweezer positions                            â”‚        â”‚
â”‚  â”‚  â”‚  - Particle tracking feedback from camera                      â”‚        â”‚
â”‚  â”‚  â”‚  - Manual/automatic control modes                              â”‚        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚  â”‚                           â”‚                                                 â”‚
â”‚  â”‚                           â–¼                                                 â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  â”‚       generator_service.py (Port 50053)                        â”‚        â”‚
â”‚  â”‚  â”‚                                                                 â”‚        â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  gRPC       â”‚    â”‚  CUDA GPU   â”‚    â”‚  Gerchberg-Saxton â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  Server     â”‚â”€â”€â”€â–¶â”‚  Processing â”‚â”€â”€â”€â–¶â”‚  Algorithm        â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚             â”‚    â”‚             â”‚    â”‚                    â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  Receives   â”‚    â”‚  RTX 4070/  â”‚    â”‚  - 50 iterations  â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  tweezer    â”‚    â”‚  A4000      â”‚    â”‚  - FFT on GPU     â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  positions  â”‚    â”‚  12GB VRAM  â”‚    â”‚  - Phase extract  â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚             â”‚    â”‚             â”‚    â”‚  - 512x512 output â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚        â”‚
â”‚  â”‚  â”‚         â”‚                                         â”‚            â”‚        â”‚
â”‚  â”‚  â”‚         â”‚              Hologram Generation       â”‚            â”‚        â”‚
â”‚  â”‚  â”‚         â”‚              Time: ~1-3 ms             â”‚            â”‚        â”‚
â”‚  â”‚  â”‚         â–¼                                         â–¼            â”‚        â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚        â”‚
â”‚  â”‚  â”‚  â”‚         8-bit Phase Pattern (512x512 bytes)            â”‚  â”‚        â”‚
â”‚  â”‚  â”‚  â”‚         Packed in HologramFrame protobuf                â”‚  â”‚        â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚  â”‚                           â”‚                                                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                              â”‚                                                 â”‚
â”‚                              â”‚ 10 Gigabit Ethernet                             â”‚
â”‚                              â”‚ gRPC Streaming                                  â”‚
â”‚                              â”‚ Target: 192.168.6.2:50051                       â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚
â”‚                              â”‚                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚                           SLM PC                                           â”‚
â”‚  â”‚                                                                             â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  â”‚          slm_service.py (Port 50051)                           â”‚        â”‚
â”‚  â”‚  â”‚                                                                 â”‚        â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  gRPC       â”‚    â”‚  Format     â”‚    â”‚  Hardware Driver  â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  Server     â”‚â”€â”€â”€â–¶â”‚  Converter  â”‚â”€â”€â”€â–¶â”‚                    â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚             â”‚    â”‚             â”‚    â”‚                    â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  Receives   â”‚    â”‚  8-bit â†’    â”‚    â”‚  - SDK C/C++ DLL  â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  hologram   â”‚    â”‚  Hardware   â”‚    â”‚  - Write_image()  â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  frames     â”‚    â”‚  format     â”‚    â”‚  - Buffer flip    â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  from Main  â”‚    â”‚             â”‚    â”‚  - VSync timing   â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  PC         â”‚    â”‚             â”‚    â”‚                    â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚        â”‚
â”‚  â”‚  â”‚                                                   â”‚            â”‚        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚  â”‚                                                      â”‚                     â”‚
â”‚  â”‚                                                      â–¼                     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  â”‚                  SLM Hardware (PCIE Connection)                â”‚        â”‚
â”‚  â”‚  â”‚                                                                 â”‚        â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚        â”‚
â”‚  â”‚  â”‚  â”‚   PCIE      â”‚    â”‚  Liquid     â”‚    â”‚   Optical Output  â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  Interface  â”‚â”€â”€â”€â–¶â”‚  Crystal    â”‚â”€â”€â”€â–¶â”‚                    â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚             â”‚    â”‚  Array      â”‚    â”‚                    â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  512x512    â”‚    â”‚             â”‚    â”‚  - Fourier plane  â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  Phase      â”‚    â”‚  Phase      â”‚    â”‚  - Multiple traps â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  modulation â”‚    â”‚  Modulation â”‚    â”‚  - Beam steering  â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â”‚  60-120Hz   â”‚    â”‚  0-2Ï€ range â”‚    â”‚  - Intensity ctrl â”‚ â”‚        â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                                                                 â”‚
â”‚  Data Flow:                                                                    â”‚
â”‚  1. Dashboard â†’ generator_service.py (tweezer positions)                       â”‚
â”‚  2. generator_service.py â†’ CUDA GPU â†’ hologram generation (1-3ms)             â”‚
â”‚  3. generator_service.py â†’ SLM PC (10G LAN gRPC streaming)                     â”‚
â”‚  4. slm_service.py â†’ SLM Hardware (PCIE) â†’ display update                      â”‚
â”‚                                                                                 â”‚
â”‚  Network Configuration:                                                        â”‚
â”‚  - Generator binds to: 192.168.6.1:50053                                       â”‚
â”‚  - Driver connects to: 192.168.6.2:50051                                       â”‚
â”‚  - Generator forwards to: 192.168.6.2:50051 (fire-and-forget mode)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The SLM module implements a two-tier architecture separating hologram generation from hardware control:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          SLM MODULE ARCHITECTURE                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚                        Client Applications                                  â”‚
â”‚  â”‚                                                                             â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  â”‚ Dashboard   â”‚    â”‚   Camera    â”‚    â”‚  External   â”‚    â”‚   Direct    â”‚  â”‚
â”‚  â”‚  â”‚  Control    â”‚    â”‚  Feedback   â”‚    â”‚  Scripts    â”‚    â”‚  Python     â”‚  â”‚
â”‚  â”‚  â”‚             â”‚    â”‚   Loop      â”‚    â”‚             â”‚    â”‚   Client    â”‚  â”‚
â”‚  â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚ â”‚Manual   â”‚ â”‚    â”‚ â”‚Position â”‚ â”‚    â”‚ â”‚Pattern  â”‚ â”‚    â”‚ â”‚Research â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ â”‚Tweezer  â”‚ â”‚    â”‚ â”‚Tracking â”‚ â”‚    â”‚ â”‚Sequencesâ”‚ â”‚    â”‚ â”‚Protocolsâ”‚ â”‚  â”‚
â”‚  â”‚  â”‚ â”‚Control  â”‚ â”‚    â”‚ â”‚Feedback â”‚ â”‚    â”‚ â”‚Scripts  â”‚ â”‚    â”‚ â”‚Automationâ”‚  â”‚
â”‚  â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”‚         â”‚                   â”‚                   â”‚                   â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚            â”‚                   â”‚                   â”‚                   â”‚       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚         â”‚        gRPC Control Service (Port 50053)         â”‚               â”‚
â”‚  â”‚         â”‚                   â”‚                   â”‚                   â”‚       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â”‚              Generator Service (generator_service.py)                 â”‚ â”‚
â”‚  â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  Command    â”‚    â”‚  Position   â”‚    â”‚     Hologram Generator     â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  Parser     â”‚    â”‚  Manager    â”‚    â”‚                             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚             â”‚    â”‚             â”‚    â”‚                             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚gRPC     â”‚ â”‚    â”‚ â”‚Tweezer  â”‚ â”‚    â”‚ â”‚Gerchbergâ”‚  â”‚CUDA     â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚Stream   â”‚ â”‚    â”‚ â”‚List     â”‚ â”‚    â”‚ â”‚-Saxton  â”‚  â”‚Kernels  â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚Handler  â”‚ â”‚    â”‚ â”‚Affine   â”‚ â”‚    â”‚ â”‚Hybrid   â”‚  â”‚FFT      â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚             â”‚    â”‚             â”‚    â”‚                             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚Protobuf â”‚ â”‚    â”‚ â”‚Scale/   â”‚ â”‚    â”‚ â”‚Target   â”‚  â”‚Phase    â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚Decode   â”‚ â”‚    â”‚ â”‚Rotate   â”‚ â”‚    â”‚ â”‚Intensityâ”‚  â”‚Retrievalâ”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚Validate â”‚ â”‚    â”‚ â”‚Trans    â”‚ â”‚    â”‚ â”‚Pattern  â”‚  â”‚Optimize â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚  â”‚                             â”‚                        â”‚                â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  â”‚                   GPU Processing Pipeline                          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚                                                                     â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  GPU Memory (RTX 4070 - 12GB VRAM)                                 â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  Complex    â”‚    â”‚    FFT      â”‚    â”‚    Phase Pattern       â”‚ â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  Field      â”‚â”€â”€â”€â–¶â”‚  Transform  â”‚â”€â”€â”€â–¶â”‚    (512x512 float)     â”‚ â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ (512x512)   â”‚    â”‚  cuFFT      â”‚    â”‚                         â”‚ â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ complex64   â”‚    â”‚  2D         â”‚    â”‚  Convert to 8-bit       â”‚ â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚  [0, 255] â†’ [0, 2Ï€]     â”‚ â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚         â–²                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚         â”‚                                            â”‚              â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚         â”‚                                            â–¼              â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  Iterative Refinement Loop (50 iterations)                 â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚                                                             â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  1. Apply target amplitude to Fourier plane                â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  2. Inverse FFT to get object plane                        â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  3. Extract phase, preserve desired amplitude              â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  4. Forward FFT back to Fourier plane                      â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  5. Repeat until convergence                               â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚                                                             â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  CUDA Optimization:                                         â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  - Pre-planned FFT (reused across iterations)              â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  - Custom kernels for phase extraction                     â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  - Pinned memory for fast hostâ†”device transfer            â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  - Stream concurrent operations                            â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”‚            â”‚                   â”‚                   â”‚                       â”‚
â”‚  â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚  â”‚                                â”‚                                           â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â”‚                 gRPC Driver Connection (Port 50054)                    â”‚ â”‚
â”‚  â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  â”‚  Generator â”€â”€â–¶ [HologramFrame] â”€â”€â–¶ Driver â”€â”€â–¶ [UpdateConfirmation]   â”‚ â”‚
â”‚  â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  â”‚  HologramFrame:                                                        â”‚ â”‚
â”‚  â”‚  â”‚  - command_id: unique UUID                                             â”‚ â”‚
â”‚  â”‚  â”‚  - hologram: bytes (512*512 uint8)                                     â”‚ â”‚
â”‚  â”‚  â”‚  - width, height: dimensions                                           â”‚ â”‚
â”‚  â”‚  â”‚  - metrics: generation timing                                          â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                      â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚         â”‚       gRPC Driver Service (Port 50054)           â”‚               â”‚
â”‚  â”‚         â”‚                                                  â”‚               â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â”‚                Driver Service (slm_service.py)                        â”‚ â”‚
â”‚  â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  â”‚   Stream    â”‚    â”‚   Format    â”‚    â”‚      Hardware Interface    â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  Receiver   â”‚    â”‚  Converter  â”‚    â”‚                             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚             â”‚    â”‚             â”‚    â”‚                             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚gRPC     â”‚ â”‚    â”‚ â”‚8-bit    â”‚ â”‚    â”‚ â”‚SDK      â”‚  â”‚Display  â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚Async    â”‚ â”‚    â”‚ â”‚Phase    â”‚ â”‚    â”‚ â”‚C/C++    â”‚  â”‚Port     â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚Stream   â”‚ â”‚    â”‚ â”‚Unwrap   â”‚ â”‚    â”‚ â”‚DLL      â”‚  â”‚HDMI/DP  â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚             â”‚    â”‚             â”‚    â”‚                             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚Buffer   â”‚ â”‚    â”‚ â”‚Vendor   â”‚ â”‚    â”‚ â”‚Write    â”‚  â”‚Flip     â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚Queue    â”‚ â”‚    â”‚ â”‚Format   â”‚ â”‚    â”‚ â”‚Image    â”‚  â”‚Buffer   â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚Manager  â”‚ â”‚    â”‚ â”‚Adapt    â”‚ â”‚    â”‚ â”‚Memory   â”‚  â”‚VSync    â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                      â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚                        Hardware Layer                                      â”‚
â”‚  â”‚                                      â”‚                                     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â”‚                  SLM Hardware (Spatial Light Modulator)                â”‚ â”‚
â”‚  â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  Display    â”‚    â”‚   Liquid    â”‚    â”‚      Optical Output        â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  Interface  â”‚â”€â”€â”€â–¶â”‚  Crystal    â”‚â”€â”€â”€â–¶â”‚                             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚             â”‚    â”‚   Array     â”‚    â”‚                             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚HDMI/DP  â”‚ â”‚    â”‚ â”‚Phase    â”‚ â”‚    â”‚ â”‚Fourier  â”‚  â”‚Optical  â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚Input    â”‚ â”‚    â”‚ â”‚Modulate â”‚ â”‚    â”‚ â”‚Trans-   â”‚  â”‚Trap     â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â”‚512x512  â”‚ â”‚    â”‚ â”‚2Ï€ range â”‚ â”‚    â”‚ â”‚form     â”‚  â”‚Pattern  â”‚   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚             â”‚    â”‚             â”‚    â”‚                             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ Refresh:    â”‚    â”‚ Response:   â”‚    â”‚ Beam steering & shaping     â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ 60-120 Hz   â”‚    â”‚ <10 ms      â”‚    â”‚ Multiple trap generation    â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ 8-bit depth â”‚    â”‚ Linear LC   â”‚    â”‚ Intensity control           â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”¬ Hologram Generation

### Gerchberg-Saxton Algorithm

The system implements a hybrid Gerchberg-Saxton algorithm optimized for GPU execution:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    GERCHBERG-SAXTON ALGORITHM PIPELINE                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  Input: Tweezer Positions [(xâ‚,yâ‚,Iâ‚), (xâ‚‚,yâ‚‚,Iâ‚‚), ..., (xâ‚™,yâ‚™,Iâ‚™)]          â”‚
â”‚         Affine Transform (scale, rotate, translate)                            â”‚
â”‚                                      â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚                   Phase 1: Target Pattern Generation                       â”‚
â”‚  â”‚                                      â”‚                                     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â”‚  Initialize Target Amplitude Array (512x512)                          â”‚ â”‚
â”‚  â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  â”‚  for each tweezer (x, y, intensity):                                  â”‚ â”‚
â”‚  â”‚  â”‚      # Apply affine transformation                                    â”‚ â”‚
â”‚  â”‚  â”‚      x', y' = transform(x, y, affine_matrix)                          â”‚ â”‚
â”‚  â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  â”‚      # Convert to pixel coordinates                                   â”‚ â”‚
â”‚  â”‚  â”‚      px = int(x' * scale + center_x)                                  â”‚ â”‚
â”‚  â”‚  â”‚      py = int(y' * scale + center_y)                                  â”‚ â”‚
â”‚  â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  â”‚      # Add Gaussian spot                                              â”‚ â”‚
â”‚  â”‚  â”‚      target[py, px] += intensity * gaussian(diameter)                 â”‚ â”‚
â”‚  â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  â”‚  # Normalize to [0, 1]                                                â”‚ â”‚
â”‚  â”‚  â”‚  target = target / max(target)                                        â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”‚                                      â”‚                                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚                   Phase 2: GPU-Accelerated Iteration                       â”‚
â”‚  â”‚                                                                             â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â”‚  Initialization on GPU:                                                â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ 1. Allocate GPU memory for complex field (512x512 complex64)    â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ 2. Create cuFFT plan (forward & inverse, reused)                â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ 3. Initialize phase with random values [0, 2Ï€]                  â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ 4. Transfer target amplitude to GPU                             â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  â”‚  Iterative Loop (typically 50 iterations):                             â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚                                                                  â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  Object Plane:  U(x,y) = A_target(x,y) Â· exp(iÏ†(x,y))          â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚                                                         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚ Forward FFT (cuFFT)                                    â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â–¼                                                         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  Fourier Plane: Å¨(u,v) = FFT{U(x,y)}                           â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚                                                         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚ Apply Target Amplitude Constraint                      â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚ Å¨'(u,v) = A_target(u,v) Â· exp(iÂ·angle(Å¨(u,v)))        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â–¼                                                         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  Constrained Fourier: Å¨'(u,v)                                  â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚                                                         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚ Inverse FFT (cuFFT)                                    â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â–¼                                                         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  Back to Object: U'(x,y) = IFFT{Å¨'(u,v)}                       â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚                                                         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚ Extract Phase (custom CUDA kernel)                     â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚ Ï†(x,y) = angle(U'(x,y))                                â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚                                                         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚                           â”‚                                     â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚                                                         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚ Check Convergence (every 10 iterations)                â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚ error = ||A_target - |U'|||                            â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚ if error < threshold: break                            â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚        â”‚                                                         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  â”‚  Post-Processing on GPU:                                               â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ 1. Normalize phase to [0, 2Ï€]                                   â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ 2. Convert to 8-bit: phase_8bit = (Ï† / 2Ï€) * 255               â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ 3. Transfer to host memory (DMA)                                â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”‚                                      â”‚                                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚                   Phase 3: Output & Metrics                                â”‚
â”‚  â”‚                                                                             â”‚
â”‚  â”‚  Output: 8-bit phase pattern (512x512 bytes)                               â”‚
â”‚  â”‚                                                                             â”‚
â”‚  â”‚  Metrics:                                                                   â”‚
â”‚  â”‚  - Generation Time: ~1-3 ms (GPU-accelerated)                              â”‚
â”‚  â”‚  - Iterations Completed: 50 (typical)                                      â”‚
â”‚  â”‚  - Convergence Error: < 0.01 (normalized)                                  â”‚
â”‚  â”‚  - Memory Transfer: ~1 MB (phase pattern)                                  â”‚
â”‚  â”‚  - GPU Utilization: 45-60% (during generation)                             â”‚
â”‚  â”‚                                                                             â”‚
â”‚  â”‚  Timing Breakdown:                                                          â”‚
â”‚  â”‚  - Target generation: ~0.2 ms                                               â”‚
â”‚  â”‚  - GPU memory transfer (Hâ†’D): ~0.3 ms                                       â”‚
â”‚  â”‚  - Iterative computation: ~1.5 ms (50 iterations @ 30Î¼s each)              â”‚
â”‚  â”‚  - GPU memory transfer (Dâ†’H): ~0.3 ms                                       â”‚
â”‚  â”‚  - gRPC transmission: ~0.5 ms                                               â”‚
â”‚  â”‚  Total: ~2.8 ms average                                                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### CUDA Optimization Techniques

```cuda
// Custom CUDA kernel for phase extraction
extern "C" __global__
void update_phase(const float* amplitude, 
                  const float* fft_real, 
                  const float* fft_imag,
                  float* output_phase, 
                  int rows, int cols) {
    int i = blockIdx.y * blockDim.y + threadIdx.y;
    int j = blockIdx.x * blockDim.x + threadIdx.x;

    if (i < rows && j < cols) {
        int idx = i * cols + j;
        
        // Calculate phase from complex components
        float phase = atan2f(fft_imag[idx], fft_real[idx]);
        
        // Store phase [0, 2Ï€]
        output_phase[idx] = phase;
    }
}

// Kernel for adding Gaussian spots
extern "C" __global__
void add_spots_kernel(float* hologram, 
                      const int* x_idx, 
                      const int* y_idx,
                      const float* intensities, 
                      int n_spots, 
                      int width, 
                      int height) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    
    if (i < n_spots) {
        int cx = x_idx[i];
        int cy = y_idx[i];
        float intensity = intensities[i];
        
        // Add Gaussian spot at (cx, cy)
        for (int dy = -10; dy <= 10; dy++) {
            for (int dx = -10; dx <= 10; dx++) {
                int px = cx + dx;
                int py = cy + dy;
                
                if (px >= 0 && px < width && py >= 0 && py < height) {
                    float r2 = dx*dx + dy*dy;
                    float gaussian = intensity * expf(-r2 / 18.0f);
                    atomicAdd(&hologram[py * width + px], gaussian);
                }
            }
        }
    }
}
```

## ğŸ–¥ï¸ Hardware Driver

### SLM SDK Integration

The driver service provides vendor-agnostic hardware abstraction:

```python
# Hardware initialization
def initialize_slm_hardware():
    global slm_lib, height, width, Bytes
    
    # Load vendor SDK
    slm_lib = CDLL("/path/to/slm_sdk.so")
    
    # Configure display
    slm_lib.Create_SDK(
        bit_depth,
        num_boards_found,
        constructed_okay,
        is_nematic_type,
        RAM_write_enable,
        use_GPU,
        max_transients,
        board_number
    )
    
    # Get dimensions
    height = slm_lib.Get_image_height(board_number)
    width = slm_lib.Get_image_width(board_number)
    Bytes = 1  # 8-bit phase
    
    return True

# Write hologram to hardware
def write_image(image_array: np.ndarray) -> None:
    """Write 8-bit phase pattern to SLM."""
    global slm_lib, height, width, Bytes
    
    # Validate input
    if image_array.dtype != np.uint8:
        raise ValueError("Phase pattern must be 8-bit uint8")
    
    if image_array.size != height * width * Bytes:
        raise ValueError(f"Size mismatch: expected {height*width*Bytes}")
    
    # Write to hardware
    retVal = slm_lib.Write_image(
        board_number,
        image_array.ctypes.data_as(POINTER(c_ubyte)),
        height * width * Bytes,
        wait_For_Trigger,
        flip_immediate,
        OutputPulseImageFlip,
        OutputPulseImageRefresh,
        timeout_ms
    )
    
    if retVal < 0:
        raise RuntimeError(f"SLM write failed with code {retVal}")
```

## âš¡ Performance Optimization

### GPU Memory Management

```python
# Pre-allocate GPU arrays
complex_field = cp.zeros((height, width), dtype=cp.complex64)
target_amplitude = cp.zeros((height, width), dtype=cp.float32)
phase_pattern = cp.zeros((height, width), dtype=cp.float32)

# Pinned memory for fast hostâ†”device transfer
import cupy.cuda.pinned_memory as pinned

host_buffer = pinned.alloc((height, width), dtype=np.uint8)

# Create persistent FFT plan (reused across generations)
from cupyx.scipy.fft import get_fft_plan

with get_fft_plan(complex_field, axes=(0, 1)) as plan:
    # Plan is cached and reused automatically
    fourier = cp.fft.fft2(complex_field)
```

### Timing Optimizations

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        PERFORMANCE OPTIMIZATION STRATEGIES                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  Baseline (No Optimization):         ~50 ms per hologram                       â”‚
â”‚  â”œâ”€ Target generation: 10 ms                                                   â”‚
â”‚  â”œâ”€ 50 FFT iterations: 35 ms                                                   â”‚
â”‚  â””â”€ Memory transfer: 5 ms                                                      â”‚
â”‚                                                                                 â”‚
â”‚  Optimization 1: Pre-planned FFT                                               â”‚
â”‚  Improvement: -20 ms (40% faster)                                              â”‚
â”‚  â”œâ”€ Cache FFT plan between calls                                               â”‚
â”‚  â”œâ”€ Reuse CUDA kernels                                                         â”‚
â”‚  â””â”€ Result: ~30 ms per hologram                                                â”‚
â”‚                                                                                 â”‚
â”‚  Optimization 2: Custom CUDA Kernels                                           â”‚
â”‚  Improvement: -10 ms (33% faster than O1)                                      â”‚
â”‚  â”œâ”€ Replace NumPy operations with CUDA                                         â”‚
â”‚  â”œâ”€ Fused operations (phase extraction + normalization)                        â”‚
â”‚  â””â”€ Result: ~20 ms per hologram                                                â”‚
â”‚                                                                                 â”‚
â”‚  Optimization 3: Pinned Memory                                                 â”‚
â”‚  Improvement: -5 ms (25% faster than O2)                                       â”‚
â”‚  â”œâ”€ Direct memory access (DMA)                                                 â”‚
â”‚  â”œâ”€ Avoid buffer copies                                                        â”‚
â”‚  â””â”€ Result: ~15 ms per hologram                                                â”‚
â”‚                                                                                 â”‚
â”‚  Optimization 4: Reduced Iterations                                            â”‚
â”‚  Improvement: -10 ms (67% faster than O3)                                      â”‚
â”‚  â”œâ”€ Adaptive convergence checking                                              â”‚
â”‚  â”œâ”€ Early termination when converged                                           â”‚
â”‚  â”œâ”€ Typical: 30-40 iterations instead of 50                                    â”‚
â”‚  â””â”€ Result: ~5 ms per hologram (avg)                                           â”‚
â”‚                                                                                 â”‚
â”‚  Optimization 5: Async Operations                                              â”‚
â”‚  Improvement: -2 ms (40% faster than O4)                                       â”‚
â”‚  â”œâ”€ Overlap computation with memory transfer                                   â”‚
â”‚  â”œâ”€ CUDA streams for concurrent operations                                     â”‚
â”‚  â””â”€ Result: ~3 ms per hologram (best case)                                     â”‚
â”‚                                                                                 â”‚
â”‚  Final Performance:                                                             â”‚
â”‚  - Average: 2-3 ms per hologram                                                â”‚
â”‚  - Peak: 1-2 ms (simple patterns)                                              â”‚
â”‚  - Worst: 5-8 ms (complex patterns with many tweezers)                         â”‚
â”‚  - Throughput: 200-500 holograms/second                                        â”‚
â”‚  - Update rate: 60-120 Hz (SLM refresh limited)                                â”‚
â”‚                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ API Reference

### Protocol Buffer Schema (`hologram.proto`)

```protobuf
syntax = "proto3";
package slm;

import "google/protobuf/timestamp.proto";

// Affine transformation parameters
message AffineParameters {
  double translate_x = 1;
  double translate_y = 2;
  double translate_z = 3;
  double rotate_x_deg = 4;
  double rotate_y_deg = 5;
  double rotate_z_deg = 6;
  double scale_x = 7;
  double scale_y = 8;
  double scale_z = 9;
  double shear_xy = 10;
  double shear_yz = 11;
  double shear_xz = 12;
}

// Single tweezer position
message TweezerPoint {
  double x = 1;
  double y = 2;
  double z = 3;
  double intensity = 4;
}

// Tweezer control command
message TweezerCommand {
  string command_id = 1;
  repeated TweezerPoint points = 2;
  AffineParameters affine = 3;
  google.protobuf.Timestamp requested_at = 4;
}

// Performance metrics
message Metrics {
  int64 generation_ms = 1;
  int64 driver_transfer_ms = 2;
  int64 slm_update_ms = 3;
  google.protobuf.Timestamp hologram_generated_at = 4;
  google.protobuf.Timestamp hologram_sent_at = 5;
  google.protobuf.Timestamp slm_ack_at = 6;
}

// Generated hologram frame
message HologramFrame {
  string command_id = 1;
  bytes hologram = 2;
  uint32 width = 3;
  uint32 height = 4;
  AffineParameters affine = 5;
  Metrics metrics = 6;
}

// Services
service ControlService {
  rpc StreamCommands(stream TweezerCommand) returns (stream CommandAcknowledge);
}

service DriverService {
  rpc PushHolograms(stream HologramFrame) returns (stream UpdateConfirmation);
}
```

### Python Client Example

```python
import grpc
import hologram_pb2 as holo_pb2
import hologram_pb2_grpc as holo_pb2_grpc

# Connect to generator service
channel = grpc.insecure_channel('localhost:50053')
stub = holo_pb2_grpc.ControlServiceStub(channel)

# Create tweezer command
command = holo_pb2.TweezerCommand()
command.command_id = "test_pattern_001"

# Add tweezer positions
point1 = command.points.add()
point1.x = 10.0
point1.y = 20.0
point1.z = 0.0
point1.intensity = 1.0

point2 = command.points.add()
point2.x = -10.0
point2.y = -20.0
point2.z = 0.0
point2.intensity = 0.8

# Set affine transform
command.affine.scale_x = 1.0
command.affine.scale_y = 1.0
command.affine.rotate_z_deg = 45.0

# Stream command and receive acknowledgments
def command_stream():
    yield command

for ack in stub.StreamCommands(command_stream()):
    print(f"Command {ack.command_id} - Stage: {ack.stage}")
    if ack.metrics.generation_ms > 0:
        print(f"Generation time: {ack.metrics.generation_ms} ms")
```

## ğŸš€ Quick Start

### Starting the Services

```bash
# Activate environment
conda activate tweezer

# Start generator service
python SLM/slm-control-server/generator_service.py \
    --port 50053 \
    --gpu-index 0 \
    --width 512 \
    --height 512 \
    --iterations 50

# Start driver service (separate terminal)
python SLM/slm-driver-server/slm_service.py \
    --port 50054 \
    --sdk-path /opt/slm_sdk

# Or use service manager
python GUI/service_manager.py
```

### Demo Client

```bash
python SLM/slm-control-server/demo_client.py \
    --host localhost:50053 \
    --pattern grid \
    --num-tweezers 16
```

## ğŸ› Troubleshooting

**GPU Not Detected**
```bash
# Verify CUDA installation
nvidia-smi
python -c "import cupy; print(cupy.cuda.runtime.getDeviceCount())"

# Check GPU index
python -c "import cupy; cupy.cuda.Device(0).use(); print('GPU 0 OK')"
```

**Poor Hologram Quality**
- Increase iteration count (50-100)
- Check target amplitude normalization
- Verify tweezer positions within bounds
- Adjust convergence threshold

**High Latency**
- Reduce iteration count
- Check GPU utilization (`nvidia-smi`)
- Optimize FFT plan caching
- Monitor memory transfer times

**SLM Hardware Issues**
- Verify SDK path and permissions
- Check display port connection
- Test with vendor software
- Review hardware specifications

## ğŸ“„ File Structure

```
SLM/
â”œâ”€â”€ hologram.proto              # Protocol buffer schema
â”œâ”€â”€ slm-control-server/
â”‚   â”œâ”€â”€ generator_service.py    # Hologram generation service
â”‚   â”œâ”€â”€ demo_client.py          # Test client
â”‚   â”œâ”€â”€ hologram_pb2.py         # Generated protobuf
â”‚   â””â”€â”€ hologram_pb2_grpc.py    # Generated gRPC stubs
â”œâ”€â”€ slm-driver-server/
â”‚   â”œâ”€â”€ slm_service.py          # Hardware driver service
â”‚   â”œâ”€â”€ hologram_pb2.py         # Generated protobuf
â”‚   â”œâ”€â”€ hologram_pb2_grpc.py    # Generated gRPC stubs
â”‚   â””â”€â”€ start_slm_service.bat   # Windows launch script
â””â”€â”€ README.md                   # This documentation
```

The SLM module provides GPU-accelerated hologram generation with sub-frame latency, enabling real-time dynamic optical trap control for advanced optical tweezer experiments.